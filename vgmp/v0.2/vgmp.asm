; *****************************************************************************
; * NABU PC VGM Player v0.2 by GTAMP (c) 2026
; * MIT licensed
; * Code generated by the free version of Gemini 3 using the fast setting
; *****************************************************************************
    ORG $0100

BDOS          EQU $0005
F_CONOUT      EQU 2
F_PRTSTR      EQU 9
F_OPEN        EQU 15
F_READ        EQU 20
F_SETDMA      EQU 26
F_SIZE        EQU 35           
F_DIRIO       EQU 6            
F_USER        EQU 32           
FCB           EQU $005C        
TBUFF         EQU $0080        

AY_REG_SEL    EQU $41
AY_DATA_WR    EQU $40

start:
    ; --- 1. Memory Setup ---
    ld hl, ($0006)      
    ld de, $0800        
    and a
    sbc hl, de
    ld sp, hl           
    ld (mem_limit), hl

    ; --- 2. User Area Persistence ---
    ld e, $FF
    ld c, F_USER
    call BDOS
    ld (orig_user), a
    ld (target_user), a

    ; --- 3. Manual Parse ---
    call manual_parse_v2

    ; --- 4. Switch to Target User ---
    ld a, (target_user)
    ld e, a
    ld c, F_USER
    call BDOS

    ; --- 5. File Open Check ---
    ld a, (FCB + 1)
    cp ' '
    jp z, file_error_logic

    ld de, FCB
    ld c, F_OPEN
    call BDOS
    inc a
    jp z, file_error_logic

    ; --- 6. Hardware/UI Initialization ---
    ld e, 26            
    ld c, F_CONOUT
    call BDOS

    ld de, msg_start    
    ld c, F_PRTSTR
    call BDOS
    
    ld de, msg_controls 
    ld c, F_PRTSTR
    call BDOS

    call init_shadow    
    call silence_ay     
    call calculate_total_parts
    call update_ui_file
    call update_ui_speed
    call update_ui_loop
    call update_ui_parts
    call update_ui_time
    
    xor a
    ld (first_load), a
    call refill_buffer

; --- MAIN PLAYER LOOP ---
vgm_main:
    ld hl, (vgm_ptr)
    ld de, (vgm_end_ptr)
    and a
    sbc hl, de
    jp nc, refill_needed 

play_next_byte:
    ld hl, (vgm_ptr)
    ld a, (hl)
    inc hl
    ld (vgm_ptr), hl

    cp $A0              
    jp z, do_ay
    cp $62              
    jp z, do_wait
    cp $61              
    jp z, do_wait_n
    cp $66              
    jp z, do_loop
    
    ld e, $FF
    ld c, F_DIRIO
    call BDOS
    or a
    jp z, vgm_main
    and $7F
    
    cp 'q'
    jp z, exit_all
    cp 'p'
    call z, pause_now
    cp 'l'
    call z, toggle_loop
    
    ; --- New Speed Control Logic ---
    cp '+'
    jr z, speed_faster
    cp '='              ; Support shifted '+'
    jr z, speed_faster
    cp '-'
    jr z, speed_slower
    jp vgm_main

speed_faster:
    ld a, (speed_val)
    or a
    jp z, vgm_main      ; Already at max speed (0 delay)
    dec a
    ld (speed_val), a
    call update_ui_speed
    jp vgm_main

speed_slower:
    ld a, (speed_val)
    cp 60               ; Safety cap for delay
    jp z, vgm_main
    inc a
    ld (speed_val), a
    call update_ui_speed
    jp vgm_main

; --- POSITIONAL MANUAL PARSER ---
manual_parse_v2:
    ld hl, FCB
    ld (hl), 0
    inc hl
    ld de, FCB + 1
    ld bc, 32
    ld (hl), ' '
    ldir
    xor a
    ld (FCB + 32), a

    ld hl, TBUFF + 1
    ld a, (TBUFF)
    ld b, a
    or a
    ret z

mp_arg_loop:
    call skip_spaces
    ld a, b
    or a
    ret z

    ld a, b
    cp 1
    jr z, mp_check_single
    
    ld a, (hl)
    inc hl
    ld d, (hl)
    dec hl
    ld a, d
    cp ' '
    jr z, mp_check_single
    jr mp_grab_filename

mp_check_single:
    ld a, (FCB)
    or a
    jr nz, mp_set_user_hex
    
    ld a, (hl)
    and $5F
    sub 'A' - 1
    ld (FCB), a
    call mp_next_arg
    jr mp_arg_loop

mp_set_user_hex:
    ld a, (hl)
    call hex_to_val
    ld (target_user), a
    call mp_next_arg
    jr mp_arg_loop

mp_grab_filename:
    ld de, FCB + 1
    ld c, 8
mp_fn_lp:
    ld a, (hl)
    cp '.'
    jr z, mp_ext
    cp ' '
    jr z, mp_done
    or a
    jr z, mp_done
    ld (de), a
    inc hl
    inc de
    dec b
    jr z, mp_done
    dec c
    jr nz, mp_fn_lp
mp_skip_to_dot:
    ld a, (hl)
    cp '.'
    jr z, mp_ext
    cp ' '
    jr z, mp_done
    inc hl
    dec b
    jr z, mp_done
    jr mp_skip_to_dot
mp_ext:
    inc hl
    dec b
    jr z, mp_done
    ld de, FCB + 9
    ld c, 3
mp_ext_lp:
    ld a, (hl)
    cp ' '
    jr z, mp_done
    or a
    jr z, mp_done
    ld (de), a
    inc hl
    inc de
    dec b
    jr z, mp_done
    dec c
    jr nz, mp_ext_lp
mp_done:
    ret

mp_next_arg:
    ld a, (hl)
    cp ' '
    jr z, skip_spaces
    inc hl
    dec b
    jr nz, mp_next_arg
    ret

skip_spaces:
    ld a, b
    or a
    ret z
    ld a, (hl)
    cp ' '
    ret nz
    inc hl
    dec b
    jr skip_spaces

hex_to_val:
    ld a, (hl)
    and $5F
    cp 'A'
    jr nc, h_letter
    sub '0'
    ret
h_letter:
    sub 'A' - 10
    ret

; --- CORE SUBROUTINES ---

do_ay:
    ld hl, (vgm_ptr)
    ld c, (hl)
    inc hl
    ld b, (hl)
    inc hl
    ld (vgm_ptr), hl
    push hl
    ld hl, ay_shadow
    ld e, c
    ld d, 0
    add hl, de
    ld (hl), b
    pop hl
    ld a, c
    cp 7
    jr nz, out_ay
    ld a, b
    and %00111111
    or %01000000
    ld b, a
out_ay:
    ld a, c
    out (AY_REG_SEL), a
    ld a, b
    out (AY_DATA_WR), a
    jp vgm_main

refill_needed:
    call silence_ay
    ld a, 5
    call set_cursor
    ld de, msg_refill
    ld c, F_PRTSTR
    call BDOS
    ld hl, (cur_part)
    inc hl
    ld (cur_part), hl
    call update_ui_parts
    call refill_buffer
    ld a, 5
    call set_cursor
    ld de, msg_blank
    ld c, F_PRTSTR
    call BDOS
    call restore_ay
    jp vgm_main

refill_buffer:
    ld hl, buffer_zone
    ld (vgm_ptr), hl
load_loop:
    push hl
    ld d, h
    ld e, l
    ld c, F_SETDMA
    call BDOS
    ld de, FCB
    ld c, F_READ
    call BDOS
    pop hl
    or a
    jr nz, load_done    
    ld de, 128
    add hl, de
    push hl
    ld de, 128
    add hl, de
    ld de, (mem_limit)
    and a
    sbc hl, de
    pop hl
    jr c, load_loop
load_done:
    ld (vgm_end_ptr), hl
    ld a, (first_load)
    or a
    ret nz
    ld hl, (buffer_zone + $34)
    ld de, $34
    add hl, de
    ld de, buffer_zone
    add hl, de
    ld (vgm_ptr), hl
    ld (vgm_restart), hl
    ld a, 1
    ld (first_load), a
    ret

do_wait:
    ld hl, (wait_count)
    inc hl
    ld (wait_count), hl
    ld de, 60           
    and a
    sbc hl, de
    jr nz, no_sec_inc
    ld hl, 0
    ld (wait_count), hl
    ld a, (time_sec)
    inc a
    cp 60
    jr nz, no_min_inc
    xor a
    ld hl, (time_min)
    inc hl
    ld (time_min), hl
no_min_inc:
    ld (time_sec), a
    call update_ui_time
no_sec_inc:
    ld a, (speed_val)
    or a
    jp z, vgm_main
    ld b, a
w_outer:
    push bc
    ld de, $0250
w_inner:
    dec de
    ld a, d
    or e
    jr nz, w_inner
    pop bc
    djnz w_outer
    jp vgm_main

do_wait_n:
    ld hl, (vgm_ptr)
    inc hl
    inc hl
    ld (vgm_ptr), hl
    jp do_wait

set_cursor:
    push af
    ld e, 27            
    ld c, F_CONOUT
    call BDOS
    ld e, '='           
    ld c, F_CONOUT
    call BDOS
    pop af
    add a, 32 + 3       
    ld e, a
    ld c, F_CONOUT
    call BDOS
    ld e, 32            
    ld c, F_CONOUT
    call BDOS
    ret

calculate_total_parts:
    ld de, FCB
    ld c, F_SIZE
    call BDOS
    ld hl, (FCB + 33)   
    ld (temp_total), hl
    ld hl, (mem_limit)
    ld de, buffer_zone
    and a
    sbc hl, de          
    ld bc, 0
div_128_lp:
    ld de, 128
    and a
    sbc hl, de
    jr c, div_128_done
    inc bc
    jr div_128_lp
div_128_done:
    ld (records_per_chunk), bc
    ld hl, (temp_total)
    ld de, (records_per_chunk)
    ld bc, 0            
part_calc_lp:
    inc bc
    and a
    sbc hl, de
    jr nc, part_calc_lp
    ld (total_parts), bc
    ld hl, 1
    ld (cur_part), hl
    ret

prt_num_16:
    ld de, -10000
    call num_digit
    ld de, -1000
    call num_digit
    ld de, -100
    call num_digit
    ld de, -10
    call num_digit
    ld de, -1
num_digit:
    ld a, '0' - 1
num_digit_lp:
    inc a
    add hl, de
    jr c, num_digit_lp
    sbc hl, de
    cp '0'
    jr nz, num_digit_out
    ld c, a
    ld a, e
    cp -1
    ld a, c
    jr z, num_digit_out
    ret                 
num_digit_out:
    ld e, a
    push hl
    push de
    ld c, F_CONOUT
    call BDOS
    pop de
    pop hl
    ret

update_ui_file:
    ld a, 0
    call set_cursor
    ld de, msg_playing
    ld c, F_PRTSTR
    call BDOS
    call print_filename
    ret

update_ui_speed:
    ld a, 1
    call set_cursor
    ld de, msg_speed_lbl
    ld c, F_PRTSTR
    call BDOS
    ld hl, (speed_val)
    ld h, 0
    call prt_num_16
    ld de, msg_blank_sm
    ld c, F_PRTSTR
    call BDOS
    ret

update_ui_loop:
    ld a, 2
    call set_cursor
    ld de, msg_loop_lbl
    ld c, F_PRTSTR
    call BDOS
    ld a, (loop_flag)
    or a
    ld de, msg_lon
    jr nz, uul_prt
    ld de, msg_loff
uul_prt:
    ld c, F_PRTSTR
    call BDOS
    ret

update_ui_time:
    ld a, 4
    call set_cursor
    ld de, msg_time_lbl
    ld c, F_PRTSTR
    call BDOS
    ld hl, (time_min)
    call prt_num_16
    ld e, ':'
    ld c, F_CONOUT
    call BDOS
    ld a, (time_sec)
    cp 10
    jr nc, p_sec
    ld e, '0'
    ld c, F_CONOUT
    call BDOS
p_sec:
    ld l, a
    ld h, 0
    call prt_num_16
    ret

update_ui_parts:
    ld a, 3
    call set_cursor
    ld de, msg_part_lbl
    ld c, F_PRTSTR
    call BDOS
    ld hl, (cur_part)
    call prt_num_16
    ld de, msg_of
    ld c, F_PRTSTR
    call BDOS
    ld hl, (total_parts)
    call prt_num_16
    ret

toggle_loop:
    ld a, (loop_flag)
    xor 1
    ld (loop_flag), a
    call update_ui_loop
    ret

pause_now:
    call silence_ay
    ld a, 5
    call set_cursor
    ld de, msg_pause
    ld c, F_PRTSTR
    call BDOS
p_w: 
    ld e, $FF
    ld c, F_DIRIO
    call BDOS
    or a
    jp z, p_w
    ld a, 5
    call set_cursor
    ld de, msg_blank
    ld c, F_PRTSTR
    call BDOS
    call restore_ay
    ret

do_loop:
    ld a, (loop_flag)
    or a
    jp z, exit_all
    call silence_ay
    xor a
    ld (FCB + 12), a
    ld (FCB + 32), a
    ld hl, 1
    ld (cur_part), hl
    ld hl, 0
    ld (time_min), hl
    ld (time_sec), a
    ld (wait_count), hl
    ld de, FCB
    ld c, F_OPEN
    call BDOS
    xor a
    ld (first_load), a
    call refill_buffer
    call update_ui_parts
    call update_ui_time
    call restore_ay
    jp vgm_main

print_filename:
    ld hl, FCB + 1
    ld b, 8
pf_name:
    ld a, (hl)
    cp ' '
    jr z, pf_ext_start
    ld e, a
    push bc
    push hl
    ld c, F_CONOUT
    call BDOS
    pop hl
    pop bc
    inc hl
    djnz pf_name
pf_ext_start:
    ld e, '.'
    ld c, F_CONOUT
    call BDOS
    ld hl, FCB + 9
    ld b, 3
pf_ext:
    ld a, (hl)
    cp ' '
    jr z, pf_done
    ld e, a
    push bc
    push hl
    ld c, F_CONOUT
    call BDOS
    pop hl
    pop bc
    inc hl
    djnz pf_ext
pf_done:
    ret

silence_ay:
    ld a, 8
    out (AY_REG_SEL), a
    xor a
    out (AY_DATA_WR), a
    ld a, 9
    out (AY_REG_SEL), a
    xor a
    out (AY_DATA_WR), a
    ld a, 10
    out (AY_REG_SEL), a
    xor a
    out (AY_DATA_WR), a
    ret

restore_ay:
    ld b, 0
r_lp:
    ld a, b
    out (AY_REG_SEL), a
    push bc
    ld hl, ay_shadow
    ld e, b
    ld d, 0
    add hl, de
    ld a, (hl)
    ld c, a
    ld a, b
    cp 7
    jr nz, r_out
    ld a, c
    and %00111111
    or %01000000
    ld c, a
r_out:
    ld a, c
    out (AY_DATA_WR), a
    pop bc
    inc b
    ld a, b
    cp 11
    jr nz, r_lp
    ret

init_shadow:
    ld hl, ay_shadow
    ld b, 14
    xor a
i_lp: 
    ld (hl), a
    inc hl
    djnz i_lp
    ld a, %01111000
    ld (ay_shadow + 7), a
    ret

file_error_logic:
	ld de, msg_start    
    ld c, F_PRTSTR
    call BDOS
    ld de, msg_err
    ld c, F_PRTSTR
    call BDOS
    jp exit_direct

exit_all:
    call silence_ay
    ld a, 7
    out (AY_REG_SEL), a
    ld a, %00111111
    out (AY_DATA_WR), a
    ld a, (orig_user)
    ld e, a
    ld c, F_USER
    call BDOS
exit_direct:
    ld c, 0
    call BDOS

; --- DATA ---
msg_start:     db "NABU PC VGM Player v0.2 by GTAMP", 13, 10, "$"
msg_controls:  db "+/-:Speed (L)oop (P)ause (Q)uit", 13, 10, "$"
msg_playing:   db "File:  ", "$"
msg_speed_lbl: db "Delay: ", "$"
msg_loop_lbl:  db "Loop:  ", "$"
msg_part_lbl:  db "Chunk: ", "$"
msg_time_lbl:  db "Time:  ", "$"
msg_of:        db " of ", "$"
msg_refill:    db "[ BUFFERING... ]", "$"
msg_blank:     db "                ", "$"
msg_blank_sm:  db "  ", "$"
msg_err:       db "Usage: V [DRIVE] [USER 0-F] FILE", 13, 10
               db "Example: V A B DOOM.VGM", 13, 10, "$"
msg_pause:     db "[ PAUSED       ]", "$"
msg_lon:       db "YES", "$"
msg_loff:      db "NO ", "$"

orig_user:     db 0
target_user:   db 0
speed_val:     db 3
loop_flag:     db 1
first_load:    db 0
time_sec:      db 0
time_min:      dw 0
wait_count:    dw 0
cur_part:      dw 1
total_parts:   dw 1
records_per_chunk: dw 0
temp_total:    dw 0
mem_limit:     dw 0
vgm_ptr:       dw 0
vgm_restart:   dw 0
vgm_end_ptr:   dw 0
ay_shadow:     ds 16      

    DS 128             
buffer_zone: