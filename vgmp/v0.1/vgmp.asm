; *****************************************************************************
; * NABU PC VGM Player v0.1 by GTAMP (c) 2026
; * MIT licensed
; * Code generated by the free version of Gemini 3 using the fast setting
; *****************************************************************************
    ORG $0100

BDOS          EQU $0005
F_CONOUT      EQU 2
F_PRTSTR      EQU 9
F_OPEN        EQU 15
F_READ        EQU 20
F_SETDMA      EQU 26
F_SIZE        EQU 35           
F_DIRIO       EQU 6            
FCB           EQU $005C        

AY_REG_SEL    EQU $41
AY_DATA_WR    EQU $40

start:
    ld hl, ($0006)      
    ld de, $0800        
    and a
    sbc hl, de
    ld sp, hl           
    ld (mem_limit), hl

    ld de, msg_start
    ld c, F_PRTSTR
    call BDOS

    ld a, (FCB + 1)
    cp ' '
    jp z, file_error_logic

    xor a
    ld (FCB + 12), a   
    ld (FCB + 32), a   
    ld de, FCB
    ld c, F_OPEN
    call BDOS
    inc a
    jp z, file_error_logic

    ; Clear Screen
    ld e, 26            
    ld c, F_CONOUT
    call BDOS

    ld de, msg_start    
    ld c, F_PRTSTR
    call BDOS
    
    ld de, msg_controls 
    ld c, F_PRTSTR
    call BDOS

    call init_shadow    
    call silence_ay     
    call calculate_total_parts
    call update_ui_file
    call update_ui_speed
    call update_ui_loop
    call update_ui_parts
    call update_ui_time
    call refill_buffer

vgm_main:
    ld hl, (vgm_ptr)
    ld de, (vgm_end_ptr)
    and a
    sbc hl, de
    jp nc, refill_needed 
    
play_next_byte:
    ld hl, (vgm_ptr)
    ld a, (hl)
    inc hl
    ld (vgm_ptr), hl

    cp $A0              
    jp z, do_ay
    cp $62              
    jp z, do_wait
    cp $61              
    jp z, do_wait_n
    cp $66              
    jp z, do_loop
    
    ld e, $FF
    ld c, F_DIRIO
    call BDOS
    or a
    jp z, vgm_main
    and $7F
    
    cp 'q'
    jp z, exit_all
    cp 'p'
    call z, pause_now
    cp 'l'
    call z, toggle_loop
    
    ; --- NEW SPEED LOGIC (0-9) ---
    cp '0'
    jp c, vgm_main
    cp ':'              
    jp nc, vgm_main
    
    sub '0'
    ; We invert this so 9 is slowest, 1 is fastest, 0 is "Native"
    ld (speed_val), a
    call update_ui_speed
    jp vgm_main

; --- UI CURSOR ---
set_cursor:
    push af
    ld e, 27            
    ld c, F_CONOUT
    call BDOS
    ld e, '='           
    ld c, F_CONOUT
    call BDOS
    pop af
    add a, 32 + 3       
    ld e, a
    ld c, F_CONOUT
    call BDOS
    ld e, 32            
    ld c, F_CONOUT
    call BDOS
    ret

; --- ENHANCED DELAY LOOP ---
do_wait:
    ld hl, (wait_count)
    inc hl
    ld (wait_count), hl
    ld de, 60           
    and a
    sbc hl, de
    jr nz, no_sec_inc
    ld (wait_count), hl 
    ld a, (time_sec)
    inc a
    cp 60
    jr nz, no_min_inc
    xor a
    ld hl, (time_min)
    inc hl
    ld (time_min), hl
no_min_inc:
    ld (time_sec), a
    call update_ui_time
no_sec_inc:
    ld a, (speed_val)
    or a
    jp z, vgm_main      ; If Speed 0, no extra delay at all

    ld b, a             ; Use speed_val as a outer loop multiplier
w_outer:
    push bc
    ld de, $0250        ; Increased base delay constant
w_inner:
    dec de
    ld a, d
    or e
    jr nz, w_inner
    pop bc
    djnz w_outer
    jp vgm_main

; ... [The rest of your logic remains intact] ...

do_wait_n:
    ld hl, (vgm_ptr)
    inc hl
    inc hl
    ld (vgm_ptr), hl
    jp do_wait

refill_needed:
    call silence_ay
    ld a, 5
    call set_cursor
    ld de, msg_refill
    ld c, F_PRTSTR
    call BDOS
    ld hl, (cur_part)
    inc hl
    ld (cur_part), hl
    call update_ui_parts
    call refill_buffer
    ld a, 5
    call set_cursor
    ld de, msg_blank
    ld c, F_PRTSTR
    call BDOS
    call restore_ay
    jp vgm_main

calculate_total_parts:
    ld de, FCB
    ld c, F_SIZE
    call BDOS
    ld hl, (FCB + 33)   
    ld (temp_total), hl
    ld hl, (mem_limit)
    ld de, buffer_zone
    and a
    sbc hl, de          
    ld bc, 0
div_128_lp:
    ld de, 128
    and a
    sbc hl, de
    jr c, div_128_done
    inc bc
    jr div_128_lp
div_128_done:
    ld (records_per_chunk), bc
    ld hl, (temp_total)
    ld de, (records_per_chunk)
    ld bc, 0            
part_calc_lp:
    inc bc
    and a
    sbc hl, de
    jr nc, part_calc_lp
    ld (total_parts), bc
    ld hl, 1
    ld (cur_part), hl
    ret

update_ui_parts:
    ld a, 3
    call set_cursor
    ld de, msg_part_lbl
    ld c, F_PRTSTR
    call BDOS
    ld hl, (cur_part)
    call prt_num_16
    ld de, msg_of
    ld c, F_PRTSTR
    call BDOS
    ld hl, (total_parts)
    call prt_num_16
    ret

prt_num_16:
    ld de, -10000
    call num_digit
    ld de, -1000
    call num_digit
    ld de, -100
    call num_digit
    ld de, -10
    call num_digit
    ld de, -1
num_digit:
    ld a, '0' - 1
num_digit_lp:
    inc a
    add hl, de
    jr c, num_digit_lp
    sbc hl, de
    cp '0'
    jr nz, num_digit_out
    ld c, a
    ld a, e
    cp -1
    ld a, c
    jr z, num_digit_out
    ret                 
num_digit_out:
    ld e, a
    push hl
    push de
    ld c, F_CONOUT
    call BDOS
    pop de
    pop hl
    ret

update_ui_file:
    ld a, 0
    call set_cursor
    ld de, msg_playing
    ld c, F_PRTSTR
    call BDOS
    call print_filename
    ret

update_ui_speed:
    ld a, 1
    call set_cursor
    ld de, msg_speed_lbl
    ld c, F_PRTSTR
    call BDOS
    ld a, (speed_val)
    add a, '0'
    ld e, a
    ld c, F_CONOUT
    call BDOS
    ret

update_ui_loop:
    ld a, 2
    call set_cursor
    ld de, msg_loop_lbl
    ld c, F_PRTSTR
    call BDOS
    ld a, (loop_flag)
    or a
    ld de, msg_lon
    jr nz, uul_prt
    ld de, msg_loff
uul_prt:
    ld c, F_PRTSTR
    call BDOS
    ret

update_ui_time:
    ld a, 4
    call set_cursor
    ld de, msg_time_lbl
    ld c, F_PRTSTR
    call BDOS
    ld hl, (time_min)
    call prt_num_16
    ld e, ':'
    ld c, F_CONOUT
    call BDOS
    ld a, (time_sec)
    cp 10
    jr nc, p_sec
    ld e, '0'
    ld c, F_CONOUT
    call BDOS
p_sec:
    ld l, a
    ld h, 0
    call prt_num_16
    ret

toggle_loop:
    ld a, (loop_flag)
    xor 1
    ld (loop_flag), a
    call update_ui_loop
    ret

do_ay:
    ld hl, (vgm_ptr)
    ld c, (hl)
    inc hl
    ld b, (hl)
    inc hl
    ld (vgm_ptr), hl
    push hl
    ld hl, ay_shadow
    ld e, c
    ld d, 0
    add hl, de
    ld (hl), b
    pop hl
    ld a, c
    cp 7
    jr nz, out_ay
    ld a, b
    and %00111111
    or %01000000
    ld b, a
out_ay:
    ld a, c
    out (AY_REG_SEL), a
    ld a, b
    out (AY_DATA_WR), a
    jp vgm_main

do_loop:
    ld a, (loop_flag)
    or a
    jp z, exit_all
    call silence_ay
    xor a
    ld (FCB + 12), a
    ld (FCB + 32), a
    ld hl, 1
    ld (cur_part), hl
    ld hl, 0
    ld (time_min), hl
    ld (time_sec), a
    ld (wait_count), hl
    ld de, FCB
    ld c, F_OPEN
    call BDOS
    xor a
    ld (first_load), a
    call refill_buffer
    call update_ui_parts
    call update_ui_time
    call restore_ay
    jp vgm_main

print_filename:
    ld hl, FCB + 1
    ld b, 8
pf_name:
    ld a, (hl)
    cp ' '
    jr z, pf_ext_start
    ld e, a
    push bc
    push hl
    ld c, F_CONOUT
    call BDOS
    pop hl
    pop bc
    inc hl
    djnz pf_name
pf_ext_start:
    ld e, '.'
    ld c, F_CONOUT
    call BDOS
    ld hl, FCB + 9
    ld b, 3
pf_ext:
    ld a, (hl)
    cp ' '
    jr z, pf_done
    ld e, a
    push bc
    push hl
    ld c, F_CONOUT
    call BDOS
    pop hl
    pop bc
    inc hl
    djnz pf_ext
pf_done:
    ret

refill_buffer:
    ld hl, buffer_zone
    ld (vgm_ptr), hl
load_loop:
    push hl
    ld d, h
    ld e, l
    ld c, F_SETDMA
    call BDOS
    ld de, FCB
    ld c, F_READ
    call BDOS
    pop hl
    or a
    jp nz, load_done    
    ld de, 128
    add hl, de
    push hl
    ld de, 128
    add hl, de
    ld de, (mem_limit)
    and a
    sbc hl, de
    pop hl
    jp c, load_loop
load_done:
    ld (vgm_end_ptr), hl
    ld a, (first_load)
    or a
    ret nz
    ld hl, (buffer_zone + $34)
    ld de, $34
    add hl, de
    ld de, buffer_zone
    add hl, de
    ld (vgm_ptr), hl
    ld (vgm_restart), hl
    ld a, 1
    ld (first_load), a
    ret

pause_now:
    call silence_ay
    ld a, 5
    call set_cursor
    ld de, msg_pause
    ld c, F_PRTSTR
    call BDOS
p_w: 
    ld e, $FF
    ld c, F_DIRIO
    call BDOS
    or a
    jp z, p_w
    ld a, 5
    call set_cursor
    ld de, msg_blank
    ld c, F_PRTSTR
    call BDOS
    call restore_ay
    ret

silence_ay:
    ld a, 8
    out (AY_REG_SEL), a
    xor a
    out (AY_DATA_WR), a
    ld a, 9
    out (AY_REG_SEL), a
    xor a
    out (AY_DATA_WR), a
    ld a, 10
    out (AY_REG_SEL), a
    xor a
    out (AY_DATA_WR), a
    ret

restore_ay:
    ld b, 0
r_lp:
    ld a, b
    out (AY_REG_SEL), a
    push bc
    ld hl, ay_shadow
    ld e, b
    ld d, 0
    add hl, de
    ld a, (hl)
    ld c, a
    ld a, b
    cp 7
    jr nz, r_out
    ld a, c
    and %00111111
    or %01000000
    ld c, a
r_out:
    ld a, c
    out (AY_DATA_WR), a
    pop bc
    inc b
    ld a, b
    cp 11
    jr nz, r_lp
    ret

init_shadow:
    ld hl, ay_shadow
    ld b, 14
    xor a
i_lp: 
    ld (hl), a
    inc hl
    djnz i_lp
    ld a, %01111000
    ld (ay_shadow + 7), a
    ret

file_error_logic:
    ld de, msg_err
    ld c, F_PRTSTR
    call BDOS
    jp exit_direct

exit_all:
    call silence_ay
    ld a, 7
    out (AY_REG_SEL), a
    ld a, %00111111
    out (AY_DATA_WR), a
exit_direct:
    ld c, 0
    call BDOS

; --- DATA ---
msg_start:   db "NABU PC VGM Player v0.40", 13, 10, "$"
msg_controls: db "0-9:Speed (L)oop (P)ause (Q)uit", 13, 10, "$"
msg_playing: db "File: ", "$"
msg_speed_lbl: db "Speed: ", "$"
msg_loop_lbl:  db "Loop:  ", "$"
msg_part_lbl:  db "Chunk: ", "$"
msg_time_lbl:  db "Time:  ", "$"
msg_of:      db " of ", "$"
msg_refill:  db "[ BUFFERING... ]", "$"
msg_blank:   db "                ", "$"
msg_err:     db "File Error - Usage: VGMP <filename>.VGM", 13, 10, "$"
msg_pause:   db "[ PAUSED       ]", "$"
msg_lon:     db "YES", "$"
msg_loff:    db "NO ", "$"

speed_val:   db 2       
loop_flag:   db 1
first_load:  db 0
time_sec:    db 0
time_min:    dw 0
wait_count:  dw 0
cur_part:    dw 1
total_parts: dw 1
records_per_chunk: dw 0
temp_total:  dw 0
mem_limit:   dw 0
vgm_ptr:     dw 0
vgm_restart: dw 0
vgm_end_ptr: dw 0
ay_shadow:   ds 16     

    DS 64              
buffer_zone: